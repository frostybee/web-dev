---
title: Session Middleware
description: Working with Middleware and Sessions
draft: true
sidebar:
  label: 'Middleware and Sessions'
  order: 6
  badge:
    text: New!
    variant: danger
---

## What is Session Middleware?

Session middleware is a component that **automatically starts and manages PHP sessions** for your web application. Instead of manually calling `session_start()` in every route, the middleware handles this for you.

### Why Use Session Middleware?

**Without middleware:**
- You must remember to call `session_start()` in every route that needs sessions
- Risk of starting sessions multiple times (causes errors)
- Repetitive code across your application
- Easy to forget in new routes

**With middleware:**
- Sessions start automatically for all routes
- Centralized session configuration
- Consistent session handling
- Write session code once, use everywhere

---

## How Session Middleware Works

When a request comes in:

1. **Middleware intercepts** the request
2. **Session starts** automatically (if not already started)
3. **Request proceeds** to your route handler
4. **Session is available** via `$_SESSION` superglobal
5. **Session saves** automatically when response is sent

**Key benefit**: You never have to think about starting sessions manually.

---

## Step-by-Step: Implementing Session Middleware

### Step 1: Create the Middleware Class

Create a new file for your session middleware in your middleware directory.

**File location:** `src/Middleware/SessionMiddleware.php`

**Basic structure:**

```php
<?php

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Http\Server\MiddlewareInterface;
use Psr\Http\Server\RequestHandlerInterface;

class SessionMiddleware implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface
    {
        // Start session if not already started
        if (session_status() === PHP_SESSION_NONE) {
            session_start();
        }

        // Continue to next middleware/route
        return $handler->handle($request);
    }
}
```

---

### Step 2: Understand the Implementation

**What does `session_status() === PHP_SESSION_NONE` do?**

It checks if a session is **not** currently active. This prevents errors from starting a session twice.

**Possible session statuses:**
- `PHP_SESSION_NONE` - No session exists
- `PHP_SESSION_ACTIVE` - Session is active
- `PHP_SESSION_DISABLED` - Sessions are disabled

**Why check before starting?**
Calling `session_start()` when a session already exists causes a PHP warning.

---

### Step 3: Add Session Configuration (Optional)

You can customize session behavior by adding configuration options:

```php
public function process(
    ServerRequestInterface $request,
    RequestHandlerInterface $handler
): ResponseInterface
{
    if (session_status() === PHP_SESSION_NONE) {
        // Optional: Configure session settings
        ini_set('session.cookie_lifetime', '86400'); // 24 hours
        ini_set('session.cookie_httponly', '1');     // Prevent JavaScript access
        ini_set('session.use_strict_mode', '1');     // Security

        session_start();
    }

    return $handler->handle($request);
}
```

**Common settings:**
- `session.cookie_lifetime` - How long the session cookie lasts (in seconds)
- `session.cookie_httponly` - Prevents JavaScript from accessing cookies (security)
- `session.use_strict_mode` - Rejects uninitialized session IDs (security)
- `session.cookie_secure` - Only send cookies over HTTPS (set to `1` in production)

---

### Step 4: Register the Middleware

Add the middleware to your application so it applies to all routes.

**In your main application file (e.g., `public/index.php` or `bootstrap.php`):**

```php
// Create the middleware instance
$sessionMiddleware = new \App\Middleware\SessionMiddleware();

// Add to application (applies to ALL routes)
$app->add($sessionMiddleware);
```

**Important**: Add session middleware early in your middleware stack so sessions are available to other middleware and routes.

---

### Step 5: Use Sessions in Your Routes

Once the middleware is registered, `$_SESSION` is automatically available in all routes:

```php
$app->get('/login', function ($request, $response) {
    // Session is already started by middleware
    $_SESSION['user_id'] = 123;
    $_SESSION['username'] = 'john_doe';

    return $response;
});

$app->get('/profile', function ($request, $response) {
    // Access session data
    $userId = $_SESSION['user_id'] ?? null;

    if (!$userId) {
        // User not logged in
        return $response->withStatus(401);
    }

    // User is logged in, continue
    return $response;
});

$app->post('/logout', function ($request, $response) {
    // Clear all session data
    session_destroy();

    return $response;
});
```

---

## Complete Workflow Example

**Scenario**: User logs in, visits protected pages, then logs out.

### 1. User Logs In

```php
$app->post('/login', function ($request, $response) {
    // Validate credentials (simplified)
    $data = $request->getParsedBody();

    if ($data['username'] === 'admin' && $data['password'] === 'secret') {
        // Store user info in session
        $_SESSION['user_id'] = 1;
        $_SESSION['username'] = 'admin';
        $_SESSION['logged_in'] = true;

        return $response->withStatus(200);
    }

    return $response->withStatus(401);
});
```

### 2. User Visits Protected Page

```php
$app->get('/dashboard', function ($request, $response) {
    // Check if user is logged in
    if (empty($_SESSION['logged_in'])) {
        // Redirect to login
        return $response->withHeader('Location', '/login')->withStatus(302);
    }

    // User is logged in, show dashboard
    $username = $_SESSION['username'];
    // ... render dashboard

    return $response;
});
```

### 3. User Logs Out

```php
$app->post('/logout', function ($request, $response) {
    // Destroy all session data
    session_destroy();

    // Redirect to home
    return $response->withHeader('Location', '/')->withStatus(302);
});
```

**The middleware ensures sessions work throughout this entire flow!**

---

## Enhanced Session Middleware (Optional)

For more advanced needs, you can enhance the middleware:

### Option 1: Add Dependency Injection

If you need to configure settings from outside:

```php
class SessionMiddleware implements MiddlewareInterface
{
    private $settings;

    public function __construct(array $settings = [])
    {
        $this->settings = $settings;
    }

    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface
    {
        if (session_status() === PHP_SESSION_NONE) {
            // Apply custom settings
            foreach ($this->settings as $key => $value) {
                ini_set($key, $value);
            }

            session_start();
        }

        return $handler->handle($request);
    }
}
```

**Usage:**

```php
$sessionMiddleware = new SessionMiddleware([
    'session.cookie_lifetime' => '7200',
    'session.cookie_httponly' => '1'
]);
```

---

### Option 2: Add Session Regeneration

Improve security by regenerating session IDs periodically:

```php
public function process(
    ServerRequestInterface $request,
    RequestHandlerInterface $handler
): ResponseInterface
{
    if (session_status() === PHP_SESSION_NONE) {
        session_start();
    }

    // Regenerate session ID periodically
    if (!isset($_SESSION['created'])) {
        $_SESSION['created'] = time();
    } else if (time() - $_SESSION['created'] > 1800) {
        // Regenerate after 30 minutes
        session_regenerate_id(true);
        $_SESSION['created'] = time();
    }

    return $handler->handle($request);
}
```

---

## Best Practices

### 1. Add Session Middleware First

Register session middleware before other middleware that need sessions:

```php
// Correct order
$app->add($sessionMiddleware);        // First
$app->add($authenticationMiddleware); // Second (can use sessions)
```

### 2. Always Check Session Existence

Even though sessions are started, always check if data exists:

```php
// Good
$userId = $_SESSION['user_id'] ?? null;

// Risky
$userId = $_SESSION['user_id']; // Could cause undefined index error
```

### 3. Secure Your Sessions in Production

For production environments:

```php
ini_set('session.cookie_secure', '1');      // HTTPS only
ini_set('session.cookie_httponly', '1');    // No JavaScript access
ini_set('session.use_strict_mode', '1');    // Reject invalid IDs
ini_set('session.cookie_samesite', 'Lax');  // CSRF protection
```

### 4. Use Meaningful Session Keys

```php
// Good - clear and descriptive
$_SESSION['user_id'] = 123;
$_SESSION['cart_items'] = [];
$_SESSION['last_activity'] = time();

// Bad - unclear
$_SESSION['u'] = 123;
$_SESSION['data'] = [];
```

### 5. Clean Up Sessions on Logout

```php
// Complete logout process
session_unset();    // Remove all session variables
session_destroy();  // Destroy the session
```

---

## Common Issues and Solutions

### Issue 1: "Session already started" Warning

**Problem**: Trying to start a session when one already exists.

**Solution**: The middleware uses `session_status()` check to prevent this. Make sure you're not calling `session_start()` elsewhere.

### Issue 2: Sessions Not Persisting

**Problem**: Session data disappears between requests.

**Possible causes:**
- Session middleware not registered
- Session cookie not being sent by browser
- Session files not writable

**Solution**: Check that middleware is added to the app and verify session save path permissions.

### Issue 3: "Cannot Send Session Cookie" Warning

**Problem**: Trying to start session after headers are sent.

**Solution**: Ensure middleware runs BEFORE any output is sent. Check for echo statements or whitespace before `<?php` tags.

### Issue 4: Session Data Not Available in Routes

**Problem**: `$_SESSION` is empty in routes.

**Solution**: Verify middleware is registered and applied globally:

```php
$app->add($sessionMiddleware); // Make sure this line exists
```

---

## Testing Your Session Middleware

### Quick Test Route

Create a test route to verify sessions work:

```php
$app->get('/session-test', function ($request, $response) {
    // Increment counter
    $_SESSION['counter'] = ($_SESSION['counter'] ?? 0) + 1;

    // Write response
    $response->getBody()->write(
        "Session working! Counter: " . $_SESSION['counter']
    );

    return $response;
});
```

**Expected behavior:**
- First visit: "Counter: 1"
- Second visit: "Counter: 2"
- Third visit: "Counter: 3"

If counter resets to 1 each time, sessions aren't persisting properly.

---

## Summary

**Key Takeaways:**

1. Session middleware **automatically starts sessions** for all routes
2. Implement `MiddlewareInterface` with session startup logic
3. Use `session_status()` check to **prevent double-start errors**
4. Register as **application-level middleware** for global availability
5. Configure security settings for **production environments**
6. Access sessions via `$_SESSION` in any route

**Implementation Checklist:**

- [ ] Create `SessionMiddleware.php` class
- [ ] Implement `MiddlewareInterface`
- [ ] Add `session_status()` check
- [ ] Call `session_start()` in process method
- [ ] Register middleware in application
- [ ] Test with a simple counter route
- [ ] Add security settings for production

**Next Steps:**

- Implement the basic session middleware
- Test with the counter route
- Build authentication using sessions
- Add session security configurations
- Create middleware that depends on sessions (e.g., auth middleware)

---

## Additional Resources

- [PHP Session Documentation](https://www.php.net/manual/en/book.session.php)
- [Session Security Best Practices](https://www.php.net/manual/en/session.security.php)
- PSR-15 Middleware Standard
- OWASP Session Management Cheat Sheet
