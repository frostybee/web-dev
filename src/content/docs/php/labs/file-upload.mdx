---
title: File Uploads with Slim Framework and PHP
sidebar:
  label: 'Understanding File Uploads'
  order: 1
  badge:
    text: Reading Material
    variant: note
---

## Introduction

- File uploads are a common feature in web applications, allowing users to **submit** documents, images, and other files to your server. 
- When a user uploads a file through an HTML form, the file data is sent to the server as part of an **HTTP POST request**. The server then processes this data and saves the file to a designated location on disk.
- Slim makes this process straightforward by providing access to uploaded files through its Request object.

---

## Part 1: Create the HTML Upload Form 
The process begins on the client-side with an HTML form. This form is what allows the user to select a file from their computer and send it to your server.

### Critical Requirements

The **required** attributes and HTML element for file upload forms:

1.  **`method="POST"`** - File uploads must use POST (GET cannot handle file data)
2.  **`enctype="multipart/form-data"`** - Tells the browser to encode form data in multiple parts, allowing files to be sent. **Without this, files won't upload.**
3.  **`<input type="file">`** - This is the specific HTML element that creates the file-selection browser interface.
3.  **`name` attribute** - The `name` you give the file input (e.g., `name="userfile"`) is the key you will use to identify and access the file on the server.

### Example

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
    <label for="userfile">Select a file to upload:</label>
    <input type="file" name="userfile" id="userfile">
    <input type="submit" value="Upload File">
</form>
```

---

### The $_FILES Superglobal

When PHP receives an uploaded file, it populates the `$_FILES` superglobal array with information about the file:

```php
$_FILES['profile_picture'] = [
    'name' => 'avatar.jpg',           // Original filename
    'type' => 'image/jpeg',           // Media type (user-provided, don't trust!)
    'tmp_name' => '/tmp/phpXXXXXX',   // Temporary location
    'error' => 0,                      // Error code
    'size' => 524288                   // File size in bytes
];
```

**Important:** The uploaded file is initially stored in a temporary location and will be **deleted automatically** after the script finishes unless you move it somewhere permanent.

---

## Part 2: Handling Uploads in Slim

Slim uses **PSR-7** which provides a clean, object-oriented interface instead of the messy `$_FILES` global array.

### Accessing Files

```php
$uploadedFiles = $request->getUploadedFiles();
$uploadedFile = $uploadedFiles['userfile'] ?? null;
```

---

### UploadedFile Object Methods

* `getError()` - Returns upload error code. `UPLOAD_ERR_OK` (0) = success
* `getSize()` - Returns file size in bytes
* `getClientFilename()` - Original filename. **Never trust this!**
* `getClientMediaType()` - Media type from browser. **Do not fully trust this!**
* `moveTo($path)` - Moves file from temp location to permanent destination

---

## Part 3: Validation

**Never trust user input.** You must validate every file.

### What to Check

1. **Upload Errors:** Check `$uploadedFile->getError() === UPLOAD_ERR_OK`
2. **File Size:** Compare `$uploadedFile->getSize()` against your maximum allowed size
3. **File Type:** Use `$uploadedFile->getClientMediaType()` to check media type against a whitelist. **Don't trust file extensions alone!**

---

## Part 4: Moving Files

PHP stores uploaded files in a **temporary directory** that gets deleted when the script finishes. You must move files to permanent storage.

### Key Points

* **Create uploads directory** with proper write permissions
* **Sanitize filenames** - The user's filename could be malicious (e.g., `../../etc/passwd`)
* **Generate new unique filenames** to prevent collisions and attacks
* **Use `moveTo()`** method: `$uploadedFile->moveTo($targetPath)`

---

## Part 5: Security is Not Optional! 

Accepting any file without validation is a **massive security hole**. A malicious user could upload a PHP shell and take over your server.

### Secure Process

1. **Check for Upload Errors** - Always verify `getError()` first
2. **Safe Directory** - Store uploads **outside** your web root (the `public` folder) to prevent execution
   * Good: `my-project/uploads/`
   * Bad: `my-project/public/uploads/`
3. **Validate File Type** - Use a **whitelist** of allowed media types
4. **Validate File Size** - Set reasonable limits (e.g., 5MB)
5. **Generate Secure Filenames** - **Never** use client filenames. Generate unique, random names

---

## Complete Flow Diagram
```
User clicks Upload
       ↓
Browser sends POST with file data
       ↓
Slim route receives request
       ↓
Get uploaded file object
       ↓
Check for errors
       ↓
Validate size & type
       ↓
Generate safe filename
       ↓
Move to permanent location
       ↓
Send success response
```
---
