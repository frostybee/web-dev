---
title: File Uploads with Slim Framework and PHP
sidebar:
  label: 'File Uploads with PHP and Slim'
  order: 1
  badge:
    text: In-Class Lab
    variant: danger
---

# Comprehensive Guide to File Uploads with Slim Framework and PHP

## Introduction

File uploads are a fundamental feature in modern web applications, allowing users to submit images, documents, and other files to your server. Understanding the entire file upload pipelineâ€”from the HTTP request to secure storageâ€”is crucial for building robust applications.

This guide takes a **progressive approach**: we'll start with traditional PHP file upload handling to understand the fundamentals, then explore how the Slim PHP framework provides a cleaner, more secure abstraction layer for the same functionality.

**What you'll learn:**
- How HTTP file uploads work with multipart form data
- Traditional PHP file handling with `$_FILES` and `move_uploaded_file()`
- Modern file handling using Slim Framework's PSR-7 interface
- Essential validation and security practices
- Best practices for production applications

---

## Part 1: Traditional PHP File Uploads

Before exploring frameworks, it's important to understand how PHP handles file uploads at a fundamental level. This knowledge will help you appreciate what frameworks do behind the scenes and debug issues when they arise.

### Understanding HTTP File Uploads

When a user uploads a file through a web form, the browser sends the data using a special encoding type called `multipart/form-data`. This encoding allows binary file data to be transmitted alongside regular text fields.

#### Creating an HTML Upload Form

Here's the basic HTML syntax for a file upload form:

```html
<form method="POST" action="/upload.php" enctype="multipart/form-data">
    <label for="userfile">Select a file to upload:</label>
    <input type="file" name="userfile" id="userfile">
    <input type="submit" value="Upload File">
</form>
```

**Critical requirements:**
1. **`method="POST"`** - File uploads must be sent via POST. GET requests cannot handle file uploads because they encode data in the URL, which has size limitations.
2. **`enctype="multipart/form-data"`** - This is the **most critical attribute**. It tells the browser to encode the form data in multiple parts, allowing files to be sent alongside regular text fields. Without this, the file will not be uploaded.
3. **`type="file"`** - The file input element creates the browser's file-selection interface.
4. **`name` attribute** - The name you give the file input (e.g., `name="userfile"`) is the key you'll use to access the file on the server.

**Why `multipart/form-data`?**

The default encoding type, `application/x-www-form-urlencoded`, only works for text data. It URL-encodes form values, which is inefficient and impractical for binary file data. The `multipart/form-data` encoding breaks the request into multiple parts (boundaries), with each part containing either a form field or a file, complete with headers describing the content.

### The $_FILES Superglobal

When PHP receives an uploaded file, it automatically populates the `$_FILES` superglobal array with information about each file. This is your primary interface for working with uploads in traditional PHP.

```php
// Structure of $_FILES for a single file
$_FILES['userfile'] = [
    'name' => 'vacation-photo.jpg',    // Original filename from user's computer
    'type' => 'image/jpeg',             // MIME type (user-provided, don't trust!)
    'tmp_name' => '/tmp/phpXXXXXX',     // Temporary location on server
    'error' => 0,                        // Error code (0 = success)
    'size' => 524288                     // File size in bytes (512 KB)
];
```

**Understanding each field:**

- **`name`**: The original filename from the user's computer. **Never trust this value** - it can contain malicious characters like `../../etc/passwd`.
- **`type`**: The MIME type sent by the browser (e.g., `image/jpeg`, `application/pdf`). **Don't trust this either** - users can easily manipulate it.
- **`tmp_name`**: PHP automatically saves the uploaded file to a temporary location. This is the actual path where you can access the file.
- **`error`**: An error code indicating upload status. `0` means success; other values indicate specific errors.
- **`size`**: File size in bytes.

**Critical concept:** The uploaded file is stored in a **temporary location** and will be **automatically deleted** when the PHP script finishes executing. You must move it to a permanent location using `move_uploaded_file()`.

### Handling File Uploads in Traditional PHP

Here's a basic example of processing a file upload with vanilla PHP:

```php
<?php
// upload.php

// Check if file was uploaded
if (!isset($_FILES['userfile'])) {
    die('No file uploaded');
}

$file = $_FILES['userfile'];

// Check for upload errors
if ($file['error'] !== UPLOAD_ERR_OK) {
    die('Upload failed with error code: ' . $file['error']);
}

// Validate file size (5MB limit)
$maxSize = 5 * 1024 * 1024; // 5 MB in bytes
if ($file['size'] > $maxSize) {
    die('File too large. Maximum size is 5MB');
}

// Validate file type (whitelist approach)
$allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$mimeType = finfo_file($finfo, $file['tmp_name']);
finfo_close($finfo);

if (!in_array($mimeType, $allowedTypes)) {
    die('Invalid file type. Only JPEG, PNG, and GIF images are allowed');
}

// Generate a safe filename
$extension = pathinfo($file['name'], PATHINFO_EXTENSION);
$newFilename = uniqid('upload_', true) . '.' . $extension;

// Define upload directory
$uploadDir = __DIR__ . '/uploads/';
if (!is_dir($uploadDir)) {
    mkdir($uploadDir, 0755, true);
}

// Move file to permanent location
$destination = $uploadDir . $newFilename;
if (move_uploaded_file($file['tmp_name'], $destination)) {
    echo "File uploaded successfully: " . htmlspecialchars($newFilename);
} else {
    die('Failed to move uploaded file');
}
?>
```

### Validation in Traditional PHP

Proper validation is non-negotiable for security. Here's what you must validate:

#### 1. Check for Upload Errors

PHP provides specific error constants:

```php
switch ($_FILES['userfile']['error']) {
    case UPLOAD_ERR_OK:
        // Success - proceed with validation
        break;
    case UPLOAD_ERR_INI_SIZE:
        die('File exceeds upload_max_filesize in php.ini');
    case UPLOAD_ERR_FORM_SIZE:
        die('File exceeds MAX_FILE_SIZE in HTML form');
    case UPLOAD_ERR_PARTIAL:
        die('File was only partially uploaded');
    case UPLOAD_ERR_NO_FILE:
        die('No file was uploaded');
    default:
        die('Unknown upload error');
}
```

#### 2. Validate File Size

Always validate server-side (client-side validation can be bypassed):

```php
$maxSize = 5 * 1024 * 1024; // 5 MB
if ($_FILES['userfile']['size'] > $maxSize) {
    die('File too large');
}
```

#### 3. Validate File Type

**Never trust the MIME type from `$_FILES['userfile']['type']`** - it comes from the user and can be spoofed. Instead:

```php
// Use fileinfo to check actual file content
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$mimeType = finfo_file($finfo, $_FILES['userfile']['tmp_name']);
finfo_close($finfo);

$allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
if (!in_array($mimeType, $allowedTypes)) {
    die('Invalid file type');
}
```

For images specifically, you can also use:

```php
$imageInfo = getimagesize($_FILES['userfile']['tmp_name']);
if ($imageInfo === false) {
    die('File is not a valid image');
}
```

### Security Considerations for Traditional PHP Uploads

#### Never Trust User Input

This principle applies to **everything** about uploaded files:
- **Filename**: Can contain path traversal attempts (`../../etc/passwd`)
- **MIME type**: Can be spoofed by the user
- **File extension**: Can be misleading (e.g., `malicious.php.jpg`)
- **File content**: Could contain embedded malicious code

#### Generate Safe Filenames

```php
// BAD - Never do this!
$destination = 'uploads/' . $_FILES['userfile']['name'];

// GOOD - Generate new filename
$extension = pathinfo($_FILES['userfile']['name'], PATHINFO_EXTENSION);
$newFilename = bin2hex(random_bytes(16)) . '.' . $extension;
```

#### Prevent Code Execution

If a user uploads a PHP file disguised as an image, it could be executed on your server. Mitigations:

1. **Store uploads outside the web root** when possible:
   ```
   Good: /var/www/myapp/uploads/  (outside public_html)
   Bad:  /var/www/myapp/public_html/uploads/
   ```

2. **Use a `.htaccess` file** in the upload directory to prevent execution:
   ```apache
   # .htaccess in uploads directory
   <FilesMatch "\.php$">
       Deny from all
   </FilesMatch>
   ```

3. **Validate file content**, not just extension

#### PHP Configuration Limits

Check these `php.ini` settings:

```php
echo 'upload_max_filesize: ' . ini_get('upload_max_filesize') . "\n";
echo 'post_max_size: ' . ini_get('post_max_size') . "\n";
echo 'max_file_uploads: ' . ini_get('max_file_uploads') . "\n";
```

- **`upload_max_filesize`**: Maximum size per file (default often 2MB)
- **`post_max_size`**: Maximum POST data size (must be â‰¥ `upload_max_filesize`)
- **`max_file_uploads`**: Maximum number of files per request

---

## Part 2: File Uploads with Slim Framework

Now that you understand traditional PHP file handling, let's explore how the Slim Framework provides a cleaner, more secure abstraction through the PSR-7 standard.

### Why Use a Framework for File Uploads?

Traditional PHP file handling has several pain points:
- The `$_FILES` superglobal is a global variable with inconsistent structure
- Error handling requires manual switch statements
- No built-in validation helpers
- Multiple file uploads create complex nested arrays

**Slim Framework improvements:**
- Clean object-oriented interface via PSR-7
- Consistent API regardless of single or multiple files
- Better error handling
- Integrates with modern PHP practices (dependency injection, middleware)

### Setting Up Slim for File Uploads

In Slim, you create a POST route to handle uploads. The framework provides a `Request` object that gives clean access to uploaded files:

```php
<?php
use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Slim\Factory\AppFactory;

require __DIR__ . '/../vendor/autoload.php';

$app = AppFactory::create();

$app->post('/upload', function (Request $request, Response $response) {
    // Your upload handling logic goes here
    return $response;
});

$app->run();
```

### Accessing Uploaded Files in Slim

Slim provides a much cleaner interface than raw `$_FILES`:

```php
$app->post('/upload', function (Request $request, Response $response) {
    // Get all uploaded files
    $uploadedFiles = $request->getUploadedFiles();

    // Get a specific file by the input name
    $uploadedFile = $uploadedFiles['userfile'] ?? null;

    if ($uploadedFile === null) {
        $response->getBody()->write('No file uploaded');
        return $response->withStatus(400);
    }

    // Continue processing...
    return $response;
});
```

### The UploadedFile Object

The `$uploadedFile` is an object implementing `Psr\Http\Message\UploadedFileInterface`. It provides these helpful methods:

```php
// Check for errors
$error = $uploadedFile->getError();
// Returns UPLOAD_ERR_OK (0) on success

// Get file size
$size = $uploadedFile->getSize();
// Returns size in bytes

// Get original filename
$clientFilename = $uploadedFile->getClientFilename();
// Returns original name from user's computer (DO NOT TRUST!)

// Get MIME type
$clientMediaType = $uploadedFile->getClientMediaType();
// Returns MIME type sent by browser (DO NOT TRUST!)

// Move file to permanent location
$uploadedFile->moveTo($destinationPath);
// This is the key method - moves file from temp to permanent location
```

**Important notes:**
- `getClientFilename()` and `getClientMediaType()` return **user-provided data** - never trust these without validation
- The `moveTo()` method handles the file move and validates that it was actually uploaded via HTTP POST

### Complete Slim Upload Example

Here's a complete example showing proper validation and error handling:

```php
$app->post('/upload', function (Request $request, Response $response) {
    $uploadedFiles = $request->getUploadedFiles();
    $uploadedFile = $uploadedFiles['userfile'] ?? null;

    // Check if file exists
    if ($uploadedFile === null) {
        $response->getBody()->write('No file uploaded');
        return $response->withStatus(400);
    }

    // Check for upload errors
    if ($uploadedFile->getError() !== UPLOAD_ERR_OK) {
        $response->getBody()->write('Upload error: ' . $uploadedFile->getError());
        return $response->withStatus(400);
    }

    // Validate file size (5MB limit)
    $maxSize = 5 * 1024 * 1024;
    if ($uploadedFile->getSize() > $maxSize) {
        $response->getBody()->write('File too large. Maximum is 5MB');
        return $response->withStatus(413); // Payload Too Large
    }

    // Validate file type using actual content
    $allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif'];

    // Get a temporary stream to check the file
    $stream = $uploadedFile->getStream();
    $tmpFile = tempnam(sys_get_temp_dir(), 'upload_check_');
    file_put_contents($tmpFile, $stream);

    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $mimeType = finfo_file($finfo, $tmpFile);
    finfo_close($finfo);
    unlink($tmpFile);

    if (!in_array($mimeType, $allowedMimeTypes)) {
        $response->getBody()->write('Invalid file type');
        return $response->withStatus(415); // Unsupported Media Type
    }

    // Generate safe filename
    $extension = pathinfo($uploadedFile->getClientFilename(), PATHINFO_EXTENSION);
    $newFilename = bin2hex(random_bytes(16)) . '.' . strtolower($extension);

    // Define upload directory
    $uploadDir = __DIR__ . '/../uploads/';
    if (!is_dir($uploadDir)) {
        mkdir($uploadDir, 0755, true);
    }

    // Move file to permanent location
    $destination = $uploadDir . $newFilename;
    $uploadedFile->moveTo($destination);

    // Success response
    $response->getBody()->write(json_encode([
        'success' => true,
        'filename' => $newFilename,
        'size' => $uploadedFile->getSize()
    ]));

    return $response
        ->withHeader('Content-Type', 'application/json')
        ->withStatus(200);
});
```

### Security Best Practices with Slim

The same security principles apply, but Slim provides some advantages:

#### 1. Store Files Outside Web Root

Slim makes this easier with directory configuration:

```php
// In your configuration or settings
$uploadPath = __DIR__ . '/../storage/uploads/'; // Outside public/
```

#### 2. Always Validate, Never Trust Client Data

```php
// BAD - Trusting client filename
$filename = $uploadedFile->getClientFilename();
$uploadedFile->moveTo('uploads/' . $filename);

// GOOD - Generate new secure filename
$ext = pathinfo($uploadedFile->getClientFilename(), PATHINFO_EXTENSION);
$newName = uniqid('file_', true) . '.' . $ext;
$uploadedFile->moveTo('uploads/' . $newName);
```

#### 3. Validate Before Moving

Always perform all validation **before** calling `moveTo()`:

```php
// Check error
if ($uploadedFile->getError() !== UPLOAD_ERR_OK) {
    return $response->withStatus(400);
}

// Validate size
if ($uploadedFile->getSize() > $maxSize) {
    return $response->withStatus(413);
}

// Validate type
// ... validation code ...

// Only move after all checks pass
$uploadedFile->moveTo($destination);
```

---

## Part 3: Common Practices and Advanced Topics

The following practices apply whether you're using traditional PHP or a framework like Slim.

### Generating Safe Filenames

Original filenames from users can cause multiple issues:

```php
// Problems with user filenames:
// - "../../../etc/passwd" (path traversal)
// - "my file.jpg" (spaces cause issues)
// - "report.php.jpg" (double extension)
// - "fileðŸ˜€.jpg" (special characters)
```

**Best practice approaches:**

```php
// Option 1: Unique ID + extension
$ext = pathinfo($originalName, PATHINFO_EXTENSION);
$newFilename = uniqid('upload_', true) . '.' . $ext;

// Option 2: Random bytes (more secure)
$ext = pathinfo($originalName, PATHINFO_EXTENSION);
$newFilename = bin2hex(random_bytes(16)) . '.' . $ext;

// Option 3: UUID (requires library)
$ext = pathinfo($originalName, PATHINFO_EXTENSION);
$newFilename = \Ramsey\Uuid\Uuid::uuid4()->toString() . '.' . $ext;
```

### Organizing Uploaded Files

Don't store all files in a single directory. Consider:

#### By Date (Recommended)

```php
$date = new DateTime();
$subPath = $date->format('Y/m/d');
$fullPath = $uploadDir . $subPath . '/';

if (!is_dir($fullPath)) {
    mkdir($fullPath, 0755, true);
}

$destination = $fullPath . $newFilename;
```

#### By User

```php
$userId = $_SESSION['user_id'] ?? 'anonymous';
$fullPath = $uploadDir . 'user_' . $userId . '/';

if (!is_dir($fullPath)) {
    mkdir($fullPath, 0755, true);
}
```

#### By Type

```php
$type = strpos($mimeType, 'image/') === 0 ? 'images' : 'documents';
$fullPath = $uploadDir . $type . '/';
```

### Database Metadata Storage

Store file **metadata** in your database, not the files themselves:

```sql
CREATE TABLE uploaded_files (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    stored_filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(512) NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size INT NOT NULL,
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

Example PHP code:

```php
// After successful upload
$stmt = $pdo->prepare("
    INSERT INTO uploaded_files
    (user_id, original_filename, stored_filename, file_path, mime_type, file_size)
    VALUES (?, ?, ?, ?, ?, ?)
");

$stmt->execute([
    $_SESSION['user_id'],
    $uploadedFile->getClientFilename(),
    $newFilename,
    $relativePath,
    $mimeType,
    $uploadedFile->getSize()
]);

$fileId = $pdo->lastInsertId();
```

**Benefits:**
- Track who uploaded what and when
- Implement download permissions
- Display original filenames to users while storing safe ones
- Clean up orphaned files
- Generate usage statistics

### Handling Multiple File Uploads

HTML supports multiple file selection:

```html
<form method="POST" enctype="multipart/form-data">
    <input type="file" name="documents[]" multiple>
    <button type="submit">Upload Files</button>
</form>
```

#### Traditional PHP Approach

```php
// $_FILES structure for multiple files is awkward:
$_FILES['documents'] = [
    'name' => ['file1.pdf', 'file2.pdf'],
    'type' => ['application/pdf', 'application/pdf'],
    'tmp_name' => ['/tmp/php123', '/tmp/php456'],
    'error' => [0, 0],
    'size' => [10240, 20480]
];

// Process multiple files
foreach ($_FILES['documents']['tmp_name'] as $index => $tmpName) {
    $file = [
        'name' => $_FILES['documents']['name'][$index],
        'type' => $_FILES['documents']['type'][$index],
        'tmp_name' => $tmpName,
        'error' => $_FILES['documents']['error'][$index],
        'size' => $_FILES['documents']['size'][$index]
    ];

    // Validate and process each file
    if ($file['error'] === UPLOAD_ERR_OK) {
        // ... validation ...
        move_uploaded_file($file['tmp_name'], $destination);
    }
}
```

#### Slim Approach (Cleaner)

```php
$uploadedFiles = $request->getUploadedFiles();
$files = $uploadedFiles['documents'] ?? [];

foreach ($files as $uploadedFile) {
    if ($uploadedFile->getError() === UPLOAD_ERR_OK) {
        // Validate and process - same code as single file
        // ... validation ...
        $uploadedFile->moveTo($destination);
    }
}
```

### Responding to the Client

#### Success Response

```php
// Slim JSON response
return $response
    ->withStatus(200)
    ->withJson([
        'success' => true,
        'file_id' => $fileId,
        'filename' => $newFilename,
        'url' => '/uploads/' . $newFilename
    ]);
```

#### Error Responses with Proper HTTP Status Codes

```php
// No file uploaded
return $response->withStatus(400); // Bad Request

// File too large
return $response->withStatus(413); // Payload Too Large

// Invalid file type
return $response->withStatus(415); // Unsupported Media Type

// Server error (disk full, permissions, etc.)
return $response->withStatus(500); // Internal Server Error
```

### Serving Uploaded Files

You have two main approaches:

#### 1. Direct Access (Simple but Limited)

Place files in your public directory:

```
public/
â””â”€â”€ uploads/
    â””â”€â”€ abc123.jpg
```

Access via URL: `https://yoursite.com/uploads/abc123.jpg`

**Pros:**
- Simple
- Efficient (web server handles it directly)

**Cons:**
- No permission checking
- No download tracking
- Anyone with the URL can access
- Can't customize headers

#### 2. Controlled Access via Route (Recommended)

Store files outside public directory and serve through a route:

```php
$app->get('/files/{id}', function (Request $request, Response $response, array $args) {
    $fileId = (int)$args['id'];

    // 1. Look up file in database
    $stmt = $pdo->prepare("SELECT * FROM uploaded_files WHERE id = ?");
    $stmt->execute([$fileId]);
    $file = $stmt->fetch();

    if (!$file) {
        return $response->withStatus(404);
    }

    // 2. Check user permissions
    if ($file['user_id'] !== $_SESSION['user_id']) {
        return $response->withStatus(403); // Forbidden
    }

    // 3. Verify file exists on disk
    if (!file_exists($file['file_path'])) {
        return $response->withStatus(404);
    }

    // 4. Set appropriate headers
    $response = $response
        ->withHeader('Content-Type', $file['mime_type'])
        ->withHeader('Content-Length', $file['file_size'])
        ->withHeader('Content-Disposition', 'inline; filename="' . $file['original_filename'] . '"');

    // 5. Read and output file content
    $response->getBody()->write(file_get_contents($file['file_path']));

    return $response;
});
```

**Benefits:**
- Permission checking
- Download tracking
- Custom headers (force download, custom filenames)
- Bandwidth throttling (if needed)

### Advanced Topics

#### Image Processing

For uploaded images, you might want to:

```php
// Generate thumbnail
$image = imagecreatefromjpeg($sourcePath);
$thumbnail = imagescale($image, 200, 200);
imagejpeg($thumbnail, $thumbnailPath, 85);

// Strip EXIF data (privacy concern)
$image = imagecreatefromjpeg($sourcePath);
imagejpeg($image, $cleanedPath, 90);

// Convert format
$image = imagecreatefrompng($sourcePath);
imagejpeg($image, $jpgPath, 90);
```

Libraries like **Intervention Image** make this easier:

```php
use Intervention\Image\ImageManagerStatic as Image;

Image::make($uploadedPath)
    ->fit(800, 600)
    ->save($processedPath, 85);
```

#### Chunked Uploads for Large Files

For very large files (>100MB), consider chunked uploads:

1. Client splits file into chunks
2. Each chunk uploaded separately
3. Server assembles chunks
4. Provides resumable uploads if connection drops

Libraries like **Resumable.js** or **Uppy** handle the client side.

#### Cloud Storage Integration

Instead of local filesystem, use cloud storage:

```php
// Using AWS S3 SDK
use Aws\S3\S3Client;

$s3 = new S3Client([/*...*/]);
$s3->putObject([
    'Bucket' => 'my-bucket',
    'Key' => $newFilename,
    'Body' => $uploadedFile->getStream(),
    'ContentType' => $mimeType
]);
```

**Benefits:**
- Unlimited storage
- Geographic redundancy
- CDN integration
- No local disk management

### Common Pitfalls and How to Avoid Them

#### 1. Forgetting `enctype`

Without `enctype="multipart/form-data"`, files won't upload. This is the **#1 beginner mistake**.

#### 2. Not Checking Errors

Always check error codes before assuming success:

```php
// Traditional PHP
if ($_FILES['file']['error'] !== UPLOAD_ERR_OK) { /* handle */ }

// Slim
if ($uploadedFile->getError() !== UPLOAD_ERR_OK) { /* handle */ }
```

#### 3. Trusting User Data

**Never** use original filenames or MIME types without validation.

#### 4. Insufficient Permissions

Ensure upload directory is writable:

```bash
# On Linux/Mac
chmod 755 /path/to/uploads
chown www-data:www-data /path/to/uploads
```

#### 5. Memory Limits

Very large files can exceed PHP's `memory_limit`:

```php
// Check memory limit
echo ini_get('memory_limit'); // e.g., "128M"

// If needed, increase (if hosting allows)
ini_set('memory_limit', '256M');
```

#### 6. Not Sanitizing Extensions

Always lowercase and validate extensions:

```php
$extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
$allowedExtensions = ['jpg', 'jpeg', 'png', 'pdf'];

if (!in_array($extension, $allowedExtensions)) {
    die('Invalid extension');
}
```

### Testing Your Implementation

Create comprehensive tests for:

- **Successful upload** - Valid file uploads correctly
- **Missing file** - Handles no file gracefully
- **File too large** - Rejects oversized files
- **Wrong file type** - Rejects non-whitelisted types
- **Invalid filename** - Handles malicious filenames
- **Concurrent uploads** - Multiple simultaneous uploads
- **Disk space** - Behavior when disk is full
- **Permissions** - Fails gracefully with permission errors

---

## Summary

File upload handling requires careful attention to multiple concerns:

**Core Concepts:**
- HTTP multipart/form-data encoding
- Traditional PHP with `$_FILES` and `move_uploaded_file()`
- Modern frameworks like Slim with PSR-7 interfaces

**Validation Essentials:**
- Always check error codes
- Validate file size against reasonable limits
- Validate file type using actual content (not user-provided MIME)
- Use whitelisting approach for allowed types

**Security Imperatives:**
- Never trust any user-provided data (filenames, MIME types, extensions)
- Generate new, secure filenames
- Store files outside web root when possible
- Prevent code execution in upload directories
- Validate file content, not just extension

**Best Practices:**
- Store metadata in database
- Organize files by date, user, or type
- Use proper HTTP status codes
- Implement permission-based file serving
- Process images to strip metadata and create thumbnails

By understanding both the underlying PHP mechanisms (Part 1) and how modern frameworks like Slim abstract them (Part 2), you can build secure, robust file upload functionality. Start with simple uploads, thoroughly test your implementation, and progressively add features like multiple uploads, image processing, and cloud storage as your application grows.
