---
title: 'Combined Lab: File Uploads with Slim Framework and PHP'
---

## Combined


### Step 1: Create the HTML Upload Form

The process begins on the client-side with an HTML form. This form is what allows the user to select a file from their computer and send it to your server.

**Key Concepts:**
*   **`method="POST"`:** File uploads must be sent via an HTTP POST request, as they can contain too much data for a GET request's URL.
*   **`enctype="multipart/form-data"`:** This is the **most critical attribute**. It tells the browser to encode the form data in multiple parts, allowing files to be sent alongside regular text fields. Without this, the file will not be uploaded.
*   **`<input type="file">`:** This is the specific HTML element that creates the file-selection browser interface.
*   **`name` attribute:** The `name` you give the file input (e.g., `name="userfile"`) is the key you will use to identify and access the file on the server.

**Your Task:**
Create a simple HTML file (e.g., `upload.html`). Inside, create a `<form>` element with the attributes mentioned above. Add a file input and a submit button.

```html
<!-- A snippet to guide your HTML form creation -->
<form action="/upload" method="POST" enctype="multipart/form-data">
    <label for="userfile">Select a file to upload:</label>
    <input type="file" name="userfile" id="userfile">
    <input type="submit" value="Upload File">
</form>
```


## Step 1: The HTML Form (The Client-Side)

First, we need an HTML form that allows the user to select a file. This form has two crucial requirements:

1.  The `method` attribute **must** be `POST`. You cannot send a file with a `GET` request.
2.  The `enctype` attribute **must** be set to `multipart/form-data`.

The `enctype` (encoding type) tells the browser how to package the form data. The default, `application/x-www-form-urlencoded`, isn't suitable for binary file data. `multipart/form-data` breaks the request into multiple parts, allowing the file to be sent along with other form fields.

## Step 3: Handling the Upload in Slim (The "Controller")

This is the core of our task. Slim uses the **PSR-7 standard**, which provides a clean, object-oriented way to work with uploaded files, abstracting away the messy `$_FILES` global array.

### Accessing Uploaded Files

Inside our `/upload` route, we can get all uploaded files from the `$request` object:

```php
$uploadedFiles = $request->getUploadedFiles();
```

This returns an associative array where the key is the `name` from our HTML form (`<input name="profile_pic">`).

```php
// Get our specific file
$uploadedFile = $uploadedFiles['profile_pic'] ?? null;
```


### The `UploadedFile` Object

This `$uploadedFile` is an object (specifically, an implementation of `Psr\Http\Message\UploadedFileInterface`). It has several helpful methods:

  * `$uploadedFile->getError()`: Returns the upload error code. We **must** check this first. `UPLOAD_ERR_OK` (value 0) means success.
  * `$uploadedFile->getSize()`: Returns the file size in bytes.
  * `$uploadedFile->getClientFilename()`: Returns the **original** filename from the user's computer (e.g., `my-photo.jpg`). **Never trust this name\!**
  * `$uploadedFile->getClientMediaType()`: Returns the **MIME type** sent by the browser (e.g., `image/jpeg`). **Also, do not fully trust this.**
  * `$uploadedFile->moveTo($destinationPath)`: This is the most important method. It moves the file from its temporary server location to a permanent destination you specify.


## Step 4: Security is Not Optional! ðŸš¨

You **must** validate every file. Accepting any file is a massive security hole. A malicious user could upload a PHP shell (`shell.php`) and take over your server.

Here is a secure validation and move process:

1.  **Check for Upload Errors:** Always check `$uploadedFile->getError()` first.
2.  **Define a Safe Directory:** Create a directory for your uploads. **Critically, this directory should be *outside* of your web root (the `public` folder).** This prevents the server from ever trying to *execute* an uploaded file.
      * Good: `my-project/uploads/`
      * Bad: `my-project/public/uploads/`
3.  **Validate File Type:** Don't trust the filename's extension. Check the MIME type. Use a **whitelist** of types you allow.
4.  **Validate File Size:** Set a reasonable limit (e.g., 5MB) to prevent users from filling up your server disk.
5.  **Create a New, Secure Filename:** **Never** use the client's filename (`getClientFilename()`). It can contain malicious characters (`../`) or be designed to overwrite system files. The best practice is to generate a new, unique, random name.
